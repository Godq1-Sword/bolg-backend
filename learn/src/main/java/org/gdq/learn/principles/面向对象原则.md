# 面向对象原则

## 1.开闭原则

### 1.开闭原则的定义

**Open Closed Principle - OCP**

Software entities should be open for extension,but closed for modification

软件(类与接口/方法/模块)对扩展开发,修改关闭

### 2.开闭原则的作用

开闭原则是面向对象程序设计的终极目标,它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性

- 降低耦合度,减少对软件测试的影响

- 可以提高代码的可复用性,可维护性

### 3.开闭原则的实现方法

可以通过"抽象约束、封装变化"来实现开闭原则

即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层,而将相同的可变因素封装在相同的具体实现类中

因为抽象灵活性好,适应性广,只要抽象的合理,可以基本保持软件架构的稳定.而软件中易变的细节可以从抽象派生来的实现类来进行扩展,当软件需要发生变化时,只需要根据需求重新派生一个实现类来扩展就可以了

下面以 Windows 的桌面主题为例介绍开闭原则的应用.

[例1]Windows 的桌面主题设计

分析 : Windows 的主题是桌面背景图片、窗口颜色和声音等元素的组合.用户可以根据自己的喜爱更换自己的桌面主题,也可以从网上下载新的主题.这些主题有共同的特点,可以为其定义一个抽象类(Abstract Subject),而每个具体的主题(Specific Subject)是其子类.用户窗体可以根据需要选择或者增加新的主题,而不需要修改原代码,所以它是满足开闭原则的

![ocp](https://raw.githubusercontent.com/Godq1-Sword/bolg/bolg-backend/image/ocp.png)



## 2.里氏替换

### 1.里氏替换原则的定义

**Liskov Substitution Principle  - LSP**

Inheritance should ensure that any property proved about supertype objects also holds for subtype objects

继承必须确保超类所拥有的性质在子类中仍然成立,是对开闭原则的补充,对实现抽象化的具体步骤的规范

### 2.里氏替换原则的作用

- 里氏替换原则是实现开闭原则的重要方式之一

- 它克服了继承中重写父类造成的可复用性变差的缺点
- 它是动作正确性的保证.即类的扩展不会给已有的系统引入新的错误,降低了代码出错的可能性

### 3.里氏替换原则的实现方法

里氏替换原则通俗来讲就是 : 子类可以扩展父类的功能,但不能改变父类原有的功能

如果程序违背了里氏替换原则,则继承类的对象在基类出现的地方会出现运行错误.这时其修正方法是 : 取消原来的继承关系,重新设计它们之间的关系.

下面以"几维鸟不是鸟"为例来说明里氏替换原则.

[例1]里氏替换原则在"几维鸟不是鸟"实例中的应用.

分析 : 鸟一般都会飞行,如燕子的飞行速度大概是每小时 120 千米.但是新西兰的几维鸟由于翅膀退化无法飞行.假如要设计一个实例,计算这两种鸟飞行 300 千米要花费的时间.显然,拿燕子来测试这段代码,结果正确,能计算出所需要的时间;但拿几维鸟来测试,结果会发生"除零异常"或是"无穷大",明显不符合预期

![lsp1](https://raw.githubusercontent.com/Godq1-Sword/bolg/bolg-backend/image/lsp1.png)

几维鸟类重写了鸟类的 setSpeed(double speed) 方法,这违背了里氏替换原则.正确的做法是取消几维鸟原来的继承关系,定义鸟和几维鸟的更一般的父类,如动物类,它们都有奔跑的能力.几维鸟的飞行速度虽然为 0,但奔跑速度不为 0,可以计算出其奔跑 300 千米所要花费的时间

![lsp2](https://raw.githubusercontent.com/Godq1-Sword/bolg/bolg-backend/image/lsp2.png)



## 3.依赖倒置

### 1.依赖倒置原则的定义

Dependence Inversion Principle - DIP

High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions

高层模块不应该依赖低层模块,两者都应该依赖其抽象.抽象不应该依赖细节,细节应该依赖抽象,面向接口编程

### 2.依赖、倒置原则的作用

- 依赖倒置原则可以减少并行开发引起的风险,提高系统稳定性
- 依赖倒置原则可以提高代码的可读性和可维护性,降低耦合度

### 3.依赖倒置原则的实现方法

依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则

1. 每个类尽量提供接口或抽象类或者两者都具备
2. 变量的声明类型尽量是接口或者是抽象类
3. 任何类都不应该从具体类派生
4. 使用继承时尽量遵循里氏替换原则

[例1]依赖倒置原则在"顾客购物程序"中的应用

商店类中有sell() 方法,顾客类通过该方法购物以下代码定义了顾客类通过商店A购物

```java
class Customer{ 
    public void shopping(ShopA shop){
        shopA.sell();    
    }
}	
```


但是这种设计存在缺点,如果该顾客想从另外一家商店B购物,就要将该顾客的代码修改如下

```java
class Customer{
    public void shopping(ShopB shop){
        shopB.sell();    
    }  
}	
```

顾客每更换一家商店都要修改一次代码,这明显违背了开闭原则

存在以上缺点的原因是Custom类依赖Shop类,这违背了依赖倒置原则

解决方法是:定义商店接口Shop,Custom类面向该接口编程

```java
class Customer{
    public void shopping(Shop shop){ 
        shop.sell();    
    }
}
```

![dip](https://raw.githubusercontent.com/Godq1-Sword/bolg/bolg-backend/image/dip.png)

## 4.单一职责

### 1.单一职责原则的定义

Single Responsibility Principle - SRP

There should never be more than one reason for a class to change

一个类应该有且仅有一个引起它变化的原因否则类应该被拆分

### 2.单一职责原则的优点

- 提高系统的可维护性,提高可读性
- 降低类的复杂度,变更风险降低

### 3.单一职责原则的实现方法

单一职责原则是最简单但又最难运用的原则,需要设计人员发现类的不同职责并将其分离,再封装到不同的类或模块中,而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验

[例1]操作电脑

分析 : 操作电脑都交给一个设备来管理键鼠显然不合理,鼠标操作由鼠标负责,键盘操作由键盘负责

![srp](https://raw.githubusercontent.com/Godq1-Sword/bolg/bolg-backend/image/srp.png)

## 5.接口隔离

### 1.接口隔离原则的定义

Interface Segregation Principle - ISP

Clients should not be forced to depend on methods they do not use.

The dependency of one class to another one should depend on the smallest possible interface

客户端不应该被迫依赖于它不使用的方法,一个类对另一个类的依赖应该建立在最小的接口上

接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性,体现了封装的思想

- 单一职责原则注重的是职责,而接口隔离原则注重的是对接口依赖的隔离
- 单一职责原则主要是约束类,它针对的是程序中的实现和细节;接口隔离原则主要约束接口,主要针对抽象和程序整体框架的构建

### 2.接口隔离原则的优点

接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。

- 提高系统的灵活性和可维护性
- 接口隔离提高了系统的内聚性,减少了对外交互,降低了系统的耦合性

如果接口的粒度大小定义合理,能够保证系统的稳定性;但是如果定义过小,则会造成接口数量过多,使设计复杂化

如果定义太大,灵活性降低,无法提供定制服务,给整体项目带来无法预料的风险

### 3.接口隔离原则的实现方法

- 接口尽量小,但是要有限度,一个接口只服务于一个子模块或业务逻辑
- 为依赖接口的类定制服务,只提供调用者需要的方法,屏蔽不需要的方法
- 了解环境拒绝盲从,每个项目或产品都有选定的环境因素,环境不同接口拆分的标准就不同深入了解业务逻辑
- 提高内聚,减少对外交互,使接口用最少的方法去完成最多的事情

[例1] 学生成绩管理程序

分析:学生成绩管理程序一般包含插入成绩、删除成绩、修改成绩、计算总分、计算均分、打印成绩信息、査询成绩信息等功能,如果将这些功能全部放到一个接口中显然不太合理,一个正确的做法是将它们分别放在输入模块、统计模块和打印模块3 个模块中

![isp](https://raw.githubusercontent.com/Godq1-Sword/bolg/bolg-backend/image/isp.png)

## 6.迪米特法则

### 1.迪米特法则的定义

Law of Demeter - LOD

Talk only to your immediate friends and not to strangers

如果两个软件实体无须直接通信,那么就不应当发生直接的相互调用,可以通过第三方转发该调用

### 2.迪米特法则的优点

- 降低了类之间的耦合度,提高了模块的相对独立性

- 由于亲合度降低,从而提高了类的可复用率和系统的扩展性

  但是过度使用迪米特法则会使系统产生大量的中介类,从而增加系统的复杂性,使模块之间的通信效率降低

  所以,在釆用迪米特法则时需要反复权衡,确保高内聚和低耦合的同时,保证系统的结构清晰

### 3.迪米特法则的实现方法

- 从依赖者的角度来说,只依赖应该依赖的对象

- 从被依赖者的角度说,只暴露应该暴露的方法
- 在类的结构设计上,尽量设置不变类,尽可能降低类成员的访问权限

【例1】明星与经纪人的关系实例

分析 : 明星由于全身心投入艺术,所以许多日常事务由经纪人负责处理,如与粉丝的见面会,与媒体公司的业务洽淡等.这里的经纪人是明星的朋友,而粉丝和媒体公司是陌生人,所以适合使用迪米特法则

![lod](https://raw.githubusercontent.com/Godq1-Sword/bolg/bolg-backend/image/lod.png)

## 7.合成复用原则

### 1.合成复用原则的定义

Composite Reuse Principle - CRP

它要求在软件复用时,要尽量先使用组合或者聚合等关联关系来实现,其次才考虑使用继承关系来实现

### 2.合成复用原则的重要性

通常类的复用分为继承复用和合成复用两种

继承复用虽然有简单和易实现的优点,但它也存在以下缺点

1. 继承复用破坏了类的封装性,称之"白箱"复用
2. 子类与父类的耦合度高.父类的实现的任何改变都会导致子类的实现发生变化,这不利于类的扩展与维护.
3. 限制了复用的灵活性.从父类继承而来的实现是静态的,在编译时已经定义,所以在运行时不可能发生变化

采用组合或聚合复用时,可以将已有对象纳入新对象中,使之成为新对象的一部分

1. 它维持了类的封装性.因为成分对象的内部细节是新对象看不见的,所以这种复用又称为"黑箱"复用
2. 新旧类之间的耦合度低.这种复用所需的依赖较少,新对象存取成分对象的唯一方法是通过成分对象的接口
3. 复用的灵活性高.这种复用可以在运行时动态进行,新对象可以动态地引用与成分对象类型相同的对象

### 3.合成复用原则的实现方法

合成复用原则是通过将已有的对象纳入新对象中,作为新对象的成员对象来实现的,新对象可以调用已有对象的功能,从而达到复用

下面以汽车分类管理程序为例来介绍合成复用原则的应用

【例1】汽车分类管理程序

分析 : 汽车按"动力源"划分可分为汽油汽车、电动汽车等;按"颜色"划分可分为白色汽车、黑色汽车和红色汽车等.如果同时考虑这两种分类,其组合就很多

![cpr1](https://raw.githubusercontent.com/Godq1-Sword/bolg/bolg-backend/image/crp1.png)

可以看出用继承关系实现会产生很多子类,而且增加新的"动力源"或者增加新的"颜色"都要修改源代码,这违背了开闭原则,显然不可取.但如果改用组合关系实现就能很好地解决以上问题,如图所示

![crp2](https://raw.githubusercontent.com/Godq1-Sword/bolg/bolg-backend/image/crp2.png)

## 总结

这 7 种设计原则是软件设计模式必须尽量遵循的原则,各种原则要求的侧重点不同

其中开闭原则是总纲,它告诉我们要对扩展开放,对修改关闭

里氏替换原则告诉我们不要破坏继承体系

依赖倒置原则告诉我们要面向接口编程

单一职责原则告诉我们实现类要职责单一

接口隔离原则告诉我们在设计接口的时候要精简单一

迪米特法则告诉我们要降低耦合度,降低依赖

合成复用原则告诉我们要优先使用组合或者聚合关系复用,少用继承关系复用